---
layout: post
title: RC filter
date: 2017-1-25 09:30:00
excerpt: Trying to smooth values from analog sensors
category: [coding, physical-computing]
---

If we want to smooth unwanted noises or annoying fluctuations of an electric signal we read from an analog sensor we have to create a filter.

Now we want to consider different methods to create a filter, both software and hardware, and to do this we first need to prepare a simple circuit to use to test them.

![scheme]({{ site.baseurl }}/assets/images/rc-filter/graph-01.png){: width="50%"}

Our siple circuit is composed of a:
* photoresistor;
* $$ 1 K\Omega $$ resistor, used in _pullup_ configuration.

![fritzing circuit]({{ site.baseurl }}/assets/images/rc-filter/photoresistor-00_bb.png)

Let's start reading and plotting the voltage across the photoresistor. Here's the code we are using:

{% highlight c %}

#define PHOTO A0

void setup() {
  Serial.begin(9600);

}

void loop() {
  unsigned int value = analogRead( PHOTO );
  Serial.println( value, DEC);
  delay( 5 );
}

{% endhighlight %}

We use the **Serial monitor** to print the values from the analog input, and the **Serial plotter** tool to represent them in a more intuitive way.

![serial plotter big variation]({{ site.baseurl }}/assets/images/rc-filter/00-big-variation.png)

As we see from the graph above, when we change the light headings towards the photoresistor, the graph registers big variations in ADC values: greater the quantity of light, the lower the resistance value, the same the voltage measured on analog pin 0.

On the other hand, when we let everything untouched, even if the readings from the photoresistor seems to be quite stable, they present a lot of noise.

![serial monitor]({{ site.baseurl }}/assets/images/rc-filter/serial-monitor-01.png)

From the serial monitor we read continuosly changing values (even if they only change a bit), the same we see from the _serial plotter_ graph.

![serial plotter noise]({{ site.baseurl }}/assets/images/rc-filter/00-noise.png)

Even though this behaviour seems to be different according to the type of light, we would like to filter out this noise in some way.

## The software way

Let's try first to use software to smoot our analog readings. The first method we will see is the array method.

### The array method

As we learn from Arduino [Smoothing](https://www.arduino.cc/en/Tutorial/Smoothing) tutorial, we can use an array to store consecutive readings and calculate their mean. This way we will always have an output that will be smoother than the input.

Here's the code we are using (the same shown in the tutorial):

{% highlight c %}
const int numReadings = 10;

int readings[numReadings];      // the readings from the analog input
int readIndex = 0;              // the index of the current reading
int total = 0;                  // the running total
int average = 0;                // the average

#define PHOTO A0

void setup() {
  // initialize serial communication with computer:
  Serial.begin(9600);
  // initialize all the readings to 0:
  int thisReading;
  for (thisReading = 0; thisReading < numReadings; thisReading++) {
    readings[ thisReading ] = 0;
  }
}

void loop() {
  // subtract the last reading:
  total = total - readings[readIndex];
  // read from the sensor:
  readings[readIndex] = analogRead( PHOTO );
  // add the reading to the total:
  total = total + readings[readIndex];
  // advance to the next position in the array:
  readIndex = readIndex + 1;

  // if we're at the end of the array...
  if (readIndex >= numReadings) {
    // ...wrap around to the beginning:
    readIndex = 0;
  }

  // calculate the average:
  average = total / numReadings;
  // send it to the computer as ASCII digits
  Serial.println( average, DEC);
  delay(5);        // delay in between reads for stability
}
{% endhighlight c %}

Below two screenshots for both a light changing and stable environment. As we see noise now seems to be more controlled.

![serial plotter changes]({{ site.baseurl }}/assets/images/rc-filter/01-big-variation.png)

![serial plotter noise]({{ site.baseurl }}/assets/images/rc-filter/01-noise.png)

Maybe changing the size of the array could improve the filter power but at the same time, as we read from the tutorial introduction, it will create a delay

>The higher the number of samples to keep track of, the more the readings will be smoothed, but the slower the output will respond to the input.

### The bit shift method

Another way could be that of usign a **bit shift**. In other words using this method we are reducing the [bit depth](https://en.wikipedia.org/wiki/Audio_bit_depth) of the ADC signal, loosing some of the _least significant bits_ of the original 10 bit sampled signal.

This is a very rough method that is also responsible of reducing the dynamic range of the sampled signal because of a reduction of the _quatization levels_.

Here's the code:

{% highlight c %}
#define PHOTO A0

void setup() {
  Serial.begin(9600);

}

void loop() {
  unsigned char value = analogRead( PHOTO ) >> 3;
  Serial.println( value, DEC);
  delay( 5 );
}
{% endhighlight%}

And here the plotter images:

![serial plotter cahges]({{ site.baseurl }}/assets/images/rc-filter/02-big-variation.png)

The scale of the graph has been reduced; due to the bit shift operation the maximum value that the ```value``` variable could assume is lower than $$ 1024 $$. We can also test that the more bit we shift the readings to the left, the more "_squarewavish_" the graph will appear.

![serial plotter noise]({{ site.baseurl }}/assets/images/rc-filter/02-noise.png)

### The 1-sample delay method

Recently I've read about this method on <b>Andy Farnell</b>'s **Designing Sound** book. There's a moment in chapter 10 when he describes this simple PureData patch:

![PD float Low Pass Filter patch]({{ site.baseurl }}/assets/images/rc-filter/03-puredata-lpf.png){: width="50%"}

This patch is a simple _low pass filter_ that follows this filter equation:

$$ Y_{n} = Ax_{n}+Bx_{n-1} $$

The strenght of the filter is set by the ratio $$ A : B $$. Both $$ A $$ and $$ B $$ should be between $$ 0.0 $$ and $$ 1.0 $$ and add up to $$ 1.0 $$.

Let's try this method in code with Arduino:

{% highlight c%}
#define PHOTO A0

const float A = 0.1;
float B;

float currentValue, previousValue;

void setup() {
  Serial.begin(9600);
  B = 1.0 - A;
  previousValue = 0.0;
}

void loop() {
  currentValue = analogRead( PHOTO );
  previousValue = currentValue * A + previousValue * B;
  Serial.println( int(previousValue), DEC);
  delay( 5 );
}
{% endhighlight %}

Here we have $$ A = 0.1 $$ and $$ B = 0.9 $$, so the _filter ratio_ is $$ \frac{A}{B} = 0.\overline{1} $$ . Here the images from the serial plot for both a light changing environment and a static light one.

![serial plotter big chages]({{ site.baseurl }}/assets/images/rc-filter/04-big-variation.png)

![serial plotter noise]({{ site.baseurl }}/assets/images/rc-filter/04-noise.png)

We also tried with different values for $$ A $$ and $$ B $$: here $$ A = 0.01 $$ and $$ B = 0.99 $$, for a _filter ratio_ of $$ \frac{A}{B} = 0.\overline{01} $$

![serial plotter big chages]({{ site.baseurl }}/assets/images/rc-filter/04bis-big-variation.png)

![serial plotter noise]({{ site.baseurl }}/assets/images/rc-filter/04bis-noise.png)

In both cases as we see, noise seems to be little, and we also note that the smaller $$ A $$ is, more this code seems to graph a signal similar to a capacitor charge and discarge cycle. The second one is much slower than the first one, meaning that a smaller $$ A $$ and a smaller _filter ratio_ creates a more powerful _low pass filter_ behaviour.

## The hardware way

But what about doing a filter using hardware components instead of code? We have to realize a simple circuit variation, adding the so called **RC filter**:

![RC filter scheme]({{ site.baseurl }}/assets/images/rc-filter/graph-03.png){: width="80%;"}

The theory tells us that if we accurately calibrate the value of **R** and **C**, we can precisely define $$ f_{c} $$, the **cut frequency** (where $$ f_{c} = 2\pi\omega_{c} $$) as:

$$
f_{c} = \frac{1}{2 \pi R C}
$$

In this way, all variations on the input signal will be attenuated according to their frequency. Voltage variations with a frequency $$ f > f_{c} $$ will be attenuated and will not be transferred to the output signal. On the other hand, signals with a frequency lower than $$ f_{c} $$ will be left untouched.

![RC filter graph]({{ site.baseurl }}/assets/images/rc-filter/graph-04.png){: width="80%;"}

---

Let's say we want to cancel all variations faster that $$ 1Hz $$, so we have to calculate the values for $$ R $$ and $$ C $$ accordingly.

For example, if we use $$ R_{f} = 1.5K \Omega $$ and $$ C_{f} = 100 \mu F $$, we will obtain approximately an $$ f_{c} = 1Hz $$, as we wanted. Here's our new circuit:

![scheme]({{ site.baseurl }}/assets/images/rc-filter/graph-02.png){: width="80%;"}

And here's the _Fritzing_ representation:

![fritzing]({{ site.baseurl }}/assets/images/rc-filter/photoresistor-01_bb.png)

We highly reccomend you to read the chapter 2 of the "**Practical Elctronics for inventors**" by **Paul Sherz** if you want more information about filters.
{: class="note"}

---

Now we want more: we want to find a way to compare all these different methods and to do this we need to find a way to plot different graph simultaneously and to print interesting values in a intuitive way.

We decide to use [Processing](https://processing.org/) and to program a brand new versione of the _serial plotter_.

## processing plotter

To be continued...

{% comment %}

circuito pi√π complicato con 2 punti di lettura, vogliamo graficarli contemporaneamente. Serve Processing e un sistema per inviare dati via comunicazione seriale

![fritzing scema con  2]()

In case we want to send information about 2 values via serial, we need a way for the receiving program to discriminate between the ones coming from the first and the second.

Taking inspiration from the MIDI protocol, where the most significant bit of a byte is used to differentiate between _status_ and _data_ byte, here we do the same using **0** as the most significant bit for the byte coming from the first sensor and **1** for the second.

{% endcomment %}
